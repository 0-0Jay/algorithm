// 촌수계산 : https://www.acmicpc.net/problem/2644

#include<stdio.h>
int arr[101][101], q[101], qs = -1, qr = -1, deep[10300], chk[101];
int main()
{
	int n, a, b, m, x, y, i;
	scanf("%d%d%d%d", &n, &a, &b, &m);
	for (i = 0; i < m; i++) {
		scanf("%d%d", &x, &y);                     
		arr[x][y] = 1; arr[y][x] = 1;  // #1
	}
	q[++qs] = a; deep[qs] = 0; chk[a] = 1;  // #2      
	while (qs != qr) {                             
		a = q[++qr];
		chk[a] = 1;
		if (a == b) {
      printf("%d", deep[qr]);  // #3
      break;
    }
		for (i = 1; i <= n; i++) {
			if (arr[a][i] == 1 && chk[i] == 0) {  // #4
				q[++qs] = i;
				deep[qs] = deep[qr] + 1;
				chk[i] = 1;
			}
		} 
	}
	if (a != b) {
		printf("-1");  // #5
	}
	return 0;
}

// arr은 가족관계를 2차원 table 형태로 저장하는 배열, q는 촌수계산을 위한 queue 배열, deep은 촌수를 저장하는 배열, chk는 중복방지용 배열
// #1 x, y 숫자 쌍을 받아 arr에서 x행 y열에 1, y행 x열에 1을 체크하여 서로 직계가족임을 표시했다.
//    예를 들어 2와 4가 주어지면 2행의 4열과 4행의 2열이 체크된다. 후에 4번이랑 이어진 가족은 4행에서 1로 체크된 열을 보면 된다.
// #2 q에 a를 올리고 a와 연결된 모든 가족을 탐색했다. 이때 BFS 알고리즘을 이용했다.
//    #1의 과정은 중복탐색을 방지 하지않는다. 그래서 chk배열을 사용해 해당 숫자는 탐색했음을 체크해주었다.
//    chk 배열이 없다면 2 -> 4 -> 2 -> 4 -> 2 .... 와 같은 무한 루프 탐색이 발생한다.
// #3 만약 a == b라면 a에서 b까지의 탐색이 완료되었다는 뜻이기 때문에 a에 해당하는 deep 값을 출력했다.
// #4 chk에서 해당 인덱스의 값이 0이고, arr에서 a행의 i열이 1이면 둘은 직계가족이기 때문에 q에 넣고 deep에 현재 탐색중인 깊이 + 1을 저장했다.
//    해당 수의 chk를 1로 올려주어 다시 돌아오지 않도록 했다.
// #5 만약 모든 q를 탐색했음에도 a와 b가 같지 않으면 -1을 출력시켰다.
