// 숫자카드 : http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=683&sca=3060

#include <stdio.h>
#include <string.h>
using namespace std;

char num[50];
int cnt[50];

int main() {
    scanf("%s", num);  // #1
    if (num[strlen(num) - 1] > '0') {
        cnt[strlen(num) - 1] = 1;  // #2
    }
    for (int i = strlen(num) - 2; i >= 0; i--) {
        if (num[i + 1] == '0' && num[i] > '3') break;  // #3
        int chk = 0;
        if (num[i] > 48) {  // #4
            cnt[i] += cnt[i + 1];
            if (i + 1 == strlen(num)) cnt[i]++;
        }
        if (10 <= (num[i] - 48) * 10 + (num[i + 1] - 48) && (num[i] - 48) * 10 + (num[i + 1] - 48) <= 34) {  // #5
            if (i == strlen(num) - 2) {
                cnt[i]++;
            }
            else {
                cnt[i] += cnt[i + 2];
            }
        }
    }
    printf("%d", cnt[0]);  // #6
}

// num은 입력된 숫자의 자릿수를 char 자료형으로 활용하기 위한 배열. cnt는 각 자릿수에 대한 경우의 개수를 저장하는 배열.
// #1 숫자가 공백없이 주어지기 때문에 이를 정수로 활용하는 것 보다는 문자열로 활용하는 것이 편리할 것이라고 생각하고 입력값을 문자열로 받았다.
// #2 만약 숫자의 마지막 숫자가 0이 아니라면 cnt에서 같은 자리에 경우 수를 1로 올려주었다.
//    만약 숫자가 0일 경우, 0만 있는 카드가 없기 때문에 해당 경우의 수는 존재할 수 없다.
// #3 i 번째 자리에서, (i + 1)번째 숫자가 0이고 i번째 숫자가 3보다 크다면 존재할 수 없는 경우이므로 break로 반복을 탈출했다.
//    예를 들어, 54032라는 숫자일때 i가 1이라면 i번째 숫자는 4고, (i + 1)번째 숫자는 0이 되는데, 이는 40이란 숫자카드가 없기 때문에 만들 수 없다.
// #4 char형의 '0'은 아스키코드로 변환했을 때 정수값이 48이다. 즉, 1 ~ 9라는 숫자를 한 자리 크기의 카드로 표현하는 경우를 세어 cnt의 다음 자리에 누적시켰다.
// #5 (i번째 숫자 * 10) + (i + 1)번째 숫자를 한 수가 10보다 크고, 34보다 작은 수라면 두 자리 크기의 카드로 표현하는 경우 cnt의 2칸 후 자리에 누적시켰다.
//    단, 현재 i가 가리키는 자리가 10의 자리라면 경우를 1만 올려주었다.
//    예를 들어, 12345라는 숫자인 경우 프로그램의 진행은 다음과 같다.
/*     1   2   3   4   5          1   2   3   4   5          1   2   3   4   5          1   2   3   4   5           1   2   3   4   5
                       i    ->                i         ->           i            ->        i                 ->    i
   cnt                 1                     1+0  1                 1+1  1   1             2+1  2   1   1          3+2  3   2   1   1
*/
// #6 최종적으로 0번 인덱스. 즉, 제일 높은 자리수에 누적된 수가 카드로 만들 수 있는 모든 경우의 개수가 된다.
