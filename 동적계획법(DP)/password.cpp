// 백준 2011번 암호코드 : https://www.acmicpc.net/problem/2011

#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;

char arr[5001];
long long int res[5001] = { 1, 1, };  // 초기값으로 숫자 하나일 때 1, 숫자가 없는 경우도 1로 임시 지정


int main(){
	int i;
	scanf("%s", arr);
	if (arr[0] == '0') {  // 만약 첫 숫자가 0이면 0 출력 후 프로그램 종료
		printf("0"); return 0;
	}
	for (i = 2; i <= strlen(arr); i++) {
		if (res[i - 1] == 0) {  // 만약 바로 이전의 수의 가능한 경우의 수가 0이면 이미 불가능한 수이므로 0 출력
			printf("%d", 0);
			return 0;
		}
		int tmp = (arr[i - 2] - '0') * 10 + (arr[i - 1] - '0');  // 2자리 수로 고려한 수
		if (arr[i - 1] != '0') {
			if (tmp < 27 && tmp > 0 && arr[i - 2] != '0') res[i] += res[i - 2] % 1000000;  // tmp가 알파벳 범위고, 10의 자리가 0이 아닌 경우
			res[i] += res[i - 1] % 1000000;  // 현재 자릿수를 1자리 수로 고려한 경우
		}
		else {
			if (tmp < 27 && tmp > 0) res[i] += res[i - 2] % 1000000;  // 현재 자리가 0이고 2자리 수로 고려했을 때 알파벳 범위인 경우
		}
	}
	printf("%lld", res[i - 1] % 1000000);
}

// 알고리즘 : 동적계획법(DP)
/*
풀이 : 각 자릿수의 가능한 경우의 수를 이전 수와 합쳐서 2자리로 한 경우 + 1자리로 한 경우로 계산
예를 들어 25114라면,
2의 경우 = 한자리 수이므로 2 1가지
25의 경우 = 25로 사용하는 경우 1가지(25) + 5로 사용하는 경우 1가지(2, 5) = 2가지
251의 경우 = 1로 사용하는 경우(= 25의 경우 = 2) + 51로 사용하는 경우(불가능 0) = 2가지
2511의 경우 = 1로 사용하는 경우(= 251의 경우 = 2) + 11로 사용하는 경우(= 25의 경우 = 4) = 4가지
25114의 경우 = 4로 사용하느 경우( = 2511의 경우 = 4) + 14로 사용하는 경우(= 251의 경우 = 2) = 6가지

즉, 2자리로 생각한 경우는 i - 2까지의 경우의 수에 현재 2자리를 붙인 것
ex) 2511은 25의 모든 경우에 11을 붙인 것
1자리로 생각한 경우는 i - 1까지의 경우의 수에 현재 1자리를 붙인 것
ex) 2511은 251의 모든 경우에 1을 붙인 것
*/
