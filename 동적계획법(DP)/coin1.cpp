// 동전 1 : 

#include<stdio.h>

int price[101], total[10001];

int main() {
	int n, k;
	scanf("%d%d", &n, &k);
	for (int i = 0; i < n; i++) {
		scanf("%d", &price[i]);
	}
	total[0] = 1;  // #1
	for (int i = 0; i < n; i++) {
		for (int j = 1; j <= k; j++) {
			if (j >= price[i]) {  // #2
				total[j] += total[j - price[i]];
			}
		}
	}
	printf("%d", total[k]);
}

// 주어진 동전 가치의 종류를 price에 저장하고, 만들 수 있는 경우의 수를 total에 적립시키는 방법을 사용했다.
// #1 0원을 만드는 방법은 아무 동전도 쓰지 않는경우 1가지이기 때문에 1을 저장시켜놓고 시작했다.
// #2 만약 i(price에서 꺼내온 동전의 가치)가 j(현재 만들어야하는 금액)보다 높다면, 가능한 경우의 수가 없다.
//    따라서 j가 i보다 큰경우만 계산하면 되고, 해당 경우의 수는 i를 사용하고 남은 가격을 만드는 경우의 수와 동일하다.
//    즉, 8원을 만들어야하고 5원의 동전을 꺼냈다고 가정한다면, 8원을 만들때 5원 동전을 반드시 사용하는 경우는 3원을 만드는 경우의 수와 동일하다.
//    그러므로 total[j]에 total[j-(현재 동전의 가치)]를 한 경우의 수를 누적시키는 받법을 사용했다.
