# 백준 18291번 비요뜨의 징검다리 건너기 : https://www.acmicpc.net/problem/18291

import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)

def devideConquer(a, n):  # a : 수 / n : 제곱
    if n == 1: return a  # 1제곱이면 a 그대로 반환
    tmp = devideConquer(a, n // 2)
    if n % 2 == 0:
        return tmp * tmp % 1000000007
    else:
        return tmp * tmp * a % 1000000007
        
for _ in range(int(input())):
    n = int(input()) - 2
    if n <= 0 : print(1)
    else: print(devideConquer(2, n))

# 알고리즘 : 분할정복
'''
풀이 :  분할정복을 활용하여 2의 거듭제곱을 계산한다.
문제내용이 복잡하게 적혀 있지만 요약하자면 다음과 같다.
1. 1번에서 출발해서 n번에 도착한다.
2. 중간에 위치한 돌다리는 밟거나 안밟거나 2가지 경우다.
3. 모든 경우의 수를 구한다.
즉, 모든 돌다리에 대해 각각 밟거나 안밟거나 하여 n번에 도착하는 모든 경우의 수를 구하는 문제다.
따라서 1번 위치와 n번 위치는 반드시 밟으니 2의 n - 2 제곱을 구하는 문제다.

그러나 일반적인 거듭제곱을 사용하면 n이 20만 넘어가도 어마어마한 크기의 수가 발생하고, 많은 계산 시간을 요구한다.
따라서 매 계산마다 10^9 + 7로 나눈 나머지를 구해야 하며, 분할정복이 반드시 사용되어야 한다.
분할정복은 a^2n == (a^n)^2라는 규칙을 활용한다.
예를 들어, 2의 8제곱을 계산한다고 할 때, 그냥 계산하면 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2로 7번 계산해야 한다.
그러나 위 법칙을 이용하면 (2 * 2)^2)^2)로 3번만 계산하면 된다.
'''
