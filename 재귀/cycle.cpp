// 싸이클 : http://www.jungol.co.kr/bbs/board.php?bo_table=pbank&wr_id=1828&sca=2080

#include <stdio.h>

int chk[100], t = 1, n, p;

 void cycle(int a) {
	if (chk[a * n % p] > 0) {  // #3
		printf("%d", t - chk[a * n % p]);
		return;
	}
	chk[(a * n) % p] = t++;  // #2
	cycle((a * n) % p);
	return;
}

int main() {
	scanf("%d%d", &n, &p);
	cycle(n);  // #1
}

// chk는 이미 탐색한 숫자를 체크하여 중복 탐색을 방지하기 위한 배열
// #1 cycle함수에 인수로 시작 수(n)을 주고 재귀함수를 돌렸다. n과 p는 각각 변하지 않는 수이므로 전역변수로 두고 함수에서 활용했다.
// #2 문제 조건에 따라 인수(a)에 시작 수(n)을 곱한 후 p로 나눈 나머지를 구했다.
//    chk 배열에서 방금 구한 나머지에 해당하는 인덱스의 값을 t로 주고, t를 1씩 증가시켰다.
//    이를 통해, 이후에 해당 숫자가 탐색되었다면 chk배열의 값을 확인하여 사이클 여부를 판단함과 동시에, 사이클의 크기도 구할 수 있다.
// #3 만약 사이클이 발생했다면 t(재귀 호출을 진행한 횟수) - chk[a * n % p](각 진행 단계에 어느 숫자를 탐색했는지가 t를 통해 저장되어 있음)를 구하여 출력한다.
//    예를 들어 67로 시작했을 경우, 진행과정은 다음과 같다.
/*
    숫자 진행 : 67 -> 25 ->  1 ->  5 -> 25
    t 값      :  0 ->  1 ->  2 ->  3 ->  4
    chk 값    :  0     1     2     3     1
    결과      :  4 - 1 = 3
*/
