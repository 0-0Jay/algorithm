# 백준 3020 개똥벌레 : https://www.acmicpc.net/problem/3020

import sys
input = sys.stdin.readline

n, h = map(int, input().split())
s = 1
arr = [0] * (h + 2)
for i in range(n):
    m = int(input())
    l, r = s, s * m
    if l > r: l, r = r, l
    arr[l if l > 0 else l - 1] += 1
    arr[r + 1 if r > 0 else r] -= 1
    s *= -1
    
minv, cnt = 1e12, 0
for i in range(1, h + 1):
    arr[i] += arr[i - 1]
    if arr[i] < minv:
        minv = arr[i]
        cnt = 1
    elif arr[i] == minv: cnt += 1
    
print(minv, cnt)

# 알고리즘 : 누적합
'''
풀이 : s를 -1과 1을 스왑하면서 각 경로의 인덱스를 이용해 파괴해야할 종유석/석순의 개수를 누적한다.
각 경로를 인덱스로 하는 배열(arr)을 하나 만든다.
석순인 경우에는 왼쪽부터 1씩, 종유석인 경우 오른쪽부터 1씩 누적한다.
파이썬의 경우, 인덱싱에서 음수를 사용하면 오른쪽부터 카운팅 되기 때문에, 이를 활용하기 위해 변수(s)를 스위치로 사용한다.

첫번째 장애물은 반드시 석순이므로 s를 1로 두고 시작한다.
l과 r에 s와 s * m을 저장하여 범위를 계산한다.
음수일 경우, l이 r보다 커지기 때문에 이 경우에는 l과 r을 스왑해준다.
s가 양수일 경우에는 l과 r+1에, 음수일 경우에는 l-1과 r에 각각 +1과 -1을 저장한다.
이렇게하면, 매 횟수마다 모든 범위를 돌며 석순 개수를 카운팅하지 않고, 누적합으로 한번에 계산할 수 있다.

배열이 우선 h + 2만큼 생성되었기 때문에 l과 r의 범위 선정은 다음과 같다.
우선 배열을 h + 2의 길이로 설정한 이유는 s를 1/-1 스위치로 활용하기 위함이다.
실제 사용하는 인덱스를 1~h까지만 사용할 것이고, 왼쪽에서 오른쪽 끝까지 가는 경우를 위해 h+1 인덱스가 필요하다.
ex) h가 5인경우 -> 0 1 1 1 1 1 0 -> 7 길이의 배열 필요
이 때, s가 1이면 s와 (s * m + 1)의 인덱스에, s가 -1이면 (s * m - 1)과 s에  +1/-1로 범위를 표시한다.
s가 -1일 때 -1인덱스가 실제 사용하는 인덱스 범위 밖에 있어야하므로 위의 양옆에 칸을 하나씩 추가한 것이다.

모든 +1/-1 계산이 끝났다면, 1번 인덱스부터 h번 인덱스까지 누적합을 계산하고, 최소값과 그 개수를 계산한다.
ex) 0 3 -1 1 -1 0 0 1 -3 -> 누적합 계산 -> 0 3 2 3 2 2 2 3 0
'''
