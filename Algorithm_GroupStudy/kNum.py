백준 1300번 K번째 수 : https://www.acmicpc.net/problem/1300

import sys
input = sys.stdin.readline

n = int(input())
k = int(input())
l, r = 1, n * n
while l < r:
    mid = (l + r) // 2
    cnt = 0
    for i in range(1, n + 1):
        cnt += min(mid // i, n)

    if cnt < k: l = mid + 1
    else: r = mid

print(l)

# 알고리즘 : 이분 탐색
'''
풀이 : B 배열의 k번째 인덱스의 수라는 뜻은 그 수보다 작거나 같은 수가 k개 있다는 규칙을 활용한다.
이분 탐색으로 수를 찾기위해 l은 1, r은 n*n으로 두고 찾을 수를 mid를 통해 찾는다.
만약 같은 수가 여러 개 있을 수 있으므로 답을 출력할때 l(근삿값)로 출력한다.

mid를 각 행의 숫자로 나눈 몫이 곧 그 행에서 mid보다 작거나 같은 수의 갯수다.
예를 들면 다음과 같다.
3 * 3의 A 배열에서 1행의 숫자는 1, 2, 3이고, 이번 탐색에서 5를 찾는 다면  5 // 1을 하면 몫이 5가 된다.
그러나 n이 3이므로 min 함수를 통해 1번 행에는 5보다 작거나 같은 수가 3개로 계산되게 된다.
같은 방식으로 2행의 숫자는 2, 4, 6이고, 5 // 2를 하면 몫이 2가 되며, 개수는 2개이다.
3행의 숫자는 3, 6, 9이고, 5 // 3을 하면 몫이 1 가 되며 개수는 1이 되어 5보다 작거나 같은 수는 총 6개다.
B 배열을 나열했을 때, 1 2 2 3 3 4 6 6 9 이다. 그러나 5라는 수가 실제 존재하지 않는다.
따라서 근삿값인 6이 출력된다.
'''
