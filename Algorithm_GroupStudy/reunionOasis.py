# 백준 3015번 오아시스 재결합 : https://www.acmicpc.net/problem/3015

import sys
input = sys.stdin.readline

n = int(input())
stk = []
cnt = 0
mcnt = []
for _ in range(n):
    x = int(input())
    if len(stk) == 0:  # 1번
        stk.append(x)
        mcnt.append(0)
    elif stk[-1] > x:  # 2번
        stk.append(x)
        cnt += 1
        mcnt.append(1)
    elif stk[-1] == x:  # 3번
        mcnt[-1] += 1
        cnt += mcnt[-1]
    else:  # 4번
        while stk and stk[-1] < x:
            cnt += mcnt.pop(-1)
            stk.pop(-1)
        if len(stk) == 0:
            cnt += 1
            stk.append(x)
            mcnt.append(0)
        elif stk[-1] > x:
            stk.append(x)
            cnt += 1
            mcnt.append(1)
        else:
            mcnt[-1] += 1
            cnt += mcnt[-1]
        
print(cnt)

# 알고리즘 : 스택
'''
풀이 : 연속으로 위치한 같은 키의 사람들을 예외처리 해주며 스택을 이용해 계산한다.
차례대로 줄을 설 때 가능한 경우의 수는 총 4가지이다.
1. 줄에 아무런 사람이 없어서 한 사람이 그냥 서는 경우
2. 줄의 마지막 사람의 키와 이번에 세울 사람의 키가 같은 경우
3. 줄의 마지막 사람보다 이번에 세울 사람의 키가 작은 경우
4. 줄의 마지막 사람보다 이번에 세울 사람이 키가 큰 경우

두 개의 스택을 사용한다.
stk : 현재 줄 서 있는 키들의 높이를 저장할 스택
mcnt : stk의 각 위치의 키 높이별로 몇 명을 볼 수 있는지 저장할 스택 

1번의 경우 그냥 줄을 세운다.
그러나 줄에 아무런 인원이 없기 때문에 예외적으로 0명을 mcnt에 추가한다.
자만 서있기 때문에 누구도 볼 수 없기 때문이다.

2번의 경우 새로운 키높이를 가진 인원이 들어왔기 때문에 줄에 추가한다.
이 때, 바로 앞의 사람만 볼 수 있기 때문에 1명을 mcnt에 추가하고, cnt에는 1을 누적한다. 

3번의 경우 같은 높이를 가진 사람이 들어왔다.
높이가 같은 경우, 자신보다 앞에 서있으면서 자신보다 큰 사람과도 서로 볼 수 있다.
따라서 자신보다 앞에 선 같은 키를 가진 사람 수(mcnt[-1]) + 자신보다 큰 사람 1명을 더한 사람을 볼 수 있다.
-> 실제로는 mcnt[-1] + 1을 cnt에 누적하고, 앞사람과 같은 키이므로 앞사람의 mcnt에 자신을 추가하는 과정을 수행해야 한다.
    그러나 이는 mcnt에 자신을 끼워넣은 숫자를 그저 cnt에 누적하는 것과 결과가 같기 때문에 위처럼 작성했다.

4번의 경우 이번 사람의 키가 마지막에 서있는 사람보다 큰 경우다.
이 경우, 이번 사람보다 크거나 같은 사람이 나올 때 까지 cnt에 mcnt[-1]을 누적해주면서 앞사람을 pop해준다.
왜냐하면, 두 사람 A, B, C라면 B가 C보다 작아야 A와 C가 볼 수 있기 때문에 B가 크면 A와 C에 대한 계산은 수행할 필요가 없다.
만약 모든 앞사람을 제거했다면 1번의 경우로 이번 사람을 추가한다.
이 때, 1번과 같이 빈 스택에 추가하지만, 앞사람을 제거하고 들어가기 때문에 첫번째 인원 1명을 추가로 세어줘야 한다.
이 외에 앞사람보다 이번 사람이 작으면 2번, 키가 같으면 3번의 경우로 추가한다.
'''
