# 백준 13334번 철로 : https://www.acmicpc.net/problem/13334

import heapq as hq
import sys
input = sys.stdin.readline

n = int(input())
arr = sorted([tuple(sorted(map(int, input().split()))) for _ in range(n)], key=lambda x: (x[1], x[0]))
d = int(input())
l, r = 0, 0
mx = 0
que = []

for i in range(n):
    while que and arr[i][1] > r:
        l = que[0][0]
        r = l + d
        if arr[i][1] > r: hq.heappop(que)
    if que and l > arr[i][0] and arr[i][0] + d >= que[0][1] or not que:
        l = arr[i][0]
        r = arr[i][0] + d
    if arr[i][0] >= l and arr[i][1] <= r:
        hq.heappush(que, arr[i])
        mx = max(len(que), mx)
        
print(mx)

# 알고리즘 : 우선순위 큐 + 정렬
'''
풀이 : 오른쪽 지점을 기준으로 오름차순, 오른쪽 지점이 같으면 왼쪽 지점 기준으로 오름차순 정렬 후, 우선순위 큐를 이용해 L좌표를 움직이며 탐색한다.
일단, 입력되는 모든 출발점-도착점 쌍에서 출발점이 도착점보다 오른쪽에 위치할 수도 있다.
따라서 좌표쌍을 입력받을 때, 오름차순 정렬해서 입력받는다.
받은 모든 좌표쌍은 오른쪽 좌표를 기준으로 정렬하되, 오른쪽 좌표가 같다면, 왼쪽 지점을 기준으로 오름차순 정렬한다.
오른쪽 좌표를 기준으로 하는 이유는, 철로의 범위안에 해당 좌표쌍의 오른쪽 좌표가 포함되지 않을 때만 철로를 오른쪽으로 밀어주기 위해서다.

이제 정렬된 좌표들을 순서대로 탐색한다.
이 때, 철로의 범위는 l, r로 두고, 우선순위 큐(que)를 만들어서 사용한다.
l과 r이 갱신되는 경우는 다음과 같다.
1. que에 좌표쌍이 존재하고, 현재 좌표쌍의 오른쪽 좌표가 r값보다 오른쪽에 위치한 경우
-> que의 front의 왼쪽 좌표 값으로 l을 갱신하고, r은 l + d로 갱신한다. 이렇게 했음에도 r값이 해당 좌표를 포함하지 못한다면, que에서 pop하고 한 번더 수행한다.
2. que에 좌표쌍이 존재하고, 현재 좌표쌍의 왼쪽 좌표(arr[i][0])가 l값보다 왼쪽에 위치하면서, 왼쪽 좌표에 d를 더한 값이 que의 front의 범위를 포함하는 경우
-> 즉, que의 값들을 전부 포함 할 수 있으면서 l, r의 범위를 왼쪽으로 밀어야하는 경우, 왼쪽으로 민 좌표로 수정한다.
  ex) 철로의 길이가 4인데 좌표쌍 (0, 1) 다음에 (-2, 2)가 들어오는 경우에 l, r은 (0, 4)라서 (-2, 2)를 포함할 수 없다. 
       그러나 l, r을 (-2, 2)로 수정하면 두 좌표쌍 모두 포함할 수 있다.
3. que에 아무 좌표도 없는 경우
-> que에 아무 좌표쌍이 없다는 것은 현재 범위에 철로를 설치하면 안되기때문에 현재 좌표의 왼쪽 값을 기준으로 새로 l, r을 갱신한다.

우선순위 큐에 값이 들어가는 경우는 단순히 현재 좌표쌍의 범위과 l~r 범위에 포함되면 넣는다.
이 때, 우선순위 큐의 길이의 최대값을 mx에 갱신해주면서 탐색한다.

모든 탐색이 끝났을 때, mx(우선순위 큐가 가장 길었을 때의 길이)를 출력한다.
'''
