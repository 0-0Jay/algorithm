#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;
#define M 1000000000

int n, k;
long long int dp[201][201];

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= 200; i++) {
		dp[i][0] = 1;
	}
	for (int i = 1; i <= k; i++) {
		for (int j = 1; j <= n; j++) {
			dp[i][j] = (dp[i - 1][j] % M + dp[i][j - 1] % M) % M;
		}
	}
	printf("%lld", dp[k][n]);
}

// 알고리즘 : DP
/*
풀이 : N을 K개의 수로 만드는 경우의 수는 (n - 0) 을 (k - 1)로 만드는 경우부터 (n - n)을 (k - 1)로 만드는 경우까지의 모든 경우의 수를 더한 값이다.
예를 들어 5를 3개의 수로 만드는 경우의 수는 21이다.
1. 5를 2개의 수로 만든 후 +0을 하는 경우 -> 6
2. 4를 2개의 수로 만든 후 +1을 하는 경우 -> 5
3. 3을 2개의 수로 만든 후 +2를 하는 경우 -> 4
4. 2를 2개의 수로 만든 후 +3을 하는 경우 -> 3
5. 1을 2개의 수로 만든 후 +4를 하는 경우 -> 2
6. 0을 2개의 수로 만든 후 +5를 하는 경우 -> 1
-> 21

이를 1~ 200까지 표로 그려보면 겹치는 연산이 발생하는데 겹치는 연산을 DP를 위해 요약하면
5를 3개의 수로 만드는 경우는 4를 3개의 수로 만드는 경우 + 5를 2개의 수로 만드는 경우와 같다.
위 풀이는 이 규칙을 활용해 bottom-up 방식으로 0부터 시작해 목표 n과 k까지 채우는 형식으로 풀었다.
