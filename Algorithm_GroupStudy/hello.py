# 백준 1535번 - 안녕 : https://www.acmicpc.net/problem/1535

import sys 
input = sys.stdin.readline 
sys.setrecursionlimit(100000)

n = int(input())
L = [0] + list(map(int, input().split()))  
J = [0] + list(map(int, input().split()))

DP = [[0] * 100 for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(100):
        DP[i][j] = max(DP[i - 1][j], DP[i - 1][j - L[i]] + J[i] if j - L[i] >= 0 else 0)

print(DP[n][99])

# 알고리즘 : DP(배낭 문제)
'''
풀이 : 남은 체력을 기준으로 이전 사람에서 각 체력별 최대 기쁨과 현재 인원의 기쁨의 최대 합을 계산한다.
전형적인 다이나믹 프로그래밍(배낭 채우기 알고리즘) 문제다.
소모한 체력이 0인 경우부터 99인 경우까지를 모두 순회하며 이전 단계를 탐색한다.
99까지만 탐색하는 이유는 문제에서 100의 체력을 모두 소모하면 기쁨이 모두 사라진다는 조건이 있기 때문이다.

예를 들어, 현재 내가 탐색하고자 하는 체력이 60이고 현재 인원이 소모시키는 체력이 50이라면, 다음과 같다.
1. 이전 단계(i - 1)에서 (현재 탐색할 체력(j -> 60) - 현재 인원이 소모시키는 체력(L[i] -> 50))의 체력을 소모한 경우 
	= DP[i - 1][j - L[i]]
-> 이 때, j가 L[i]보다 작을 수 있다. 이 경우 임의로 가장 작은 값인 0을 가져온다.
2. 이전 단계에서 현재 탐색할 체력만큼 이미 소모한 경우 
	= DP[i - 1][j]
1번의 경우는 현재 인원이 주는 기쁨을 받기 때문에 J[i]를 더해준다. DP[i - 1][j - L[i]] + J[i]
2번의 경우는 현재 인원과 인사하지 않고 50의 체력을 소모한 경우기 때문에 더해주지 않는다.
이 두 경우 중 더 큰 기쁨을 얻는 방법이 체력 50에서 가장 많은 기쁨을 얻는 방법이 된다.
	= max (  DP[i - 1][j]  ,   DP[i - 1][j - L[i]] + J[i]  )

마지막 사람까지 계산을 끝냈다면, DP[n][99]를 출력한다.
'''
