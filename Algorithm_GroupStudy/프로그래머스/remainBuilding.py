# 프로그래머스 2022 카카오 블라인드 채용 - 파괴되지 않은 건물 : https://school.programmers.co.kr/learn/courses/30/lessons/92344

def solution(board, skill):
    n, m = len(board), len(board[0])
    damage = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
    print(n, m)
    answer = 0
    # 1이면 공격, 2면 회복
    for tmp in skill:
        ax, ay, bx, by = tmp[1:5]
        dam = -tmp[-1] if tmp[0] == 1 else tmp[-1]
        damage[ax][ay] += dam
        damage[ax][by + 1] += -dam
        damage[bx + 1][ay] += -dam
        damage[bx + 1][by + 1] += dam

    for i in range(0, n):
        for j in range(0, m):
            if j > 0: damage[i][j] += damage[i][j - 1]
        for j in range(0, m):
            if i > 0: damage[i][j] += damage[i - 1][j]
            if damage[i][j] + board[i][j] > 0 : answer += 1
        
    return answer

# 알고리즘 : 누적합
'''
풀이 : 누적합 계산의 규칙을 활용해 추가배열에 피해를 체크하고, 한 번만 누적합 계산한다.
2차원 누적합을 매번 계산하게 되면 반드시 효율성에서 문제가 발생한다.
따라서 누적합의 규칙인, 한번 계산된 값이 끝까지 함께 계산된다는 규칙을 활용한다.

예를 들어, 길이가 5인 1차원 리스트의 1번 인덱스 부터 3번인덱스 까지 3을 더해야 한다고 가정한다.
이 경우, 그냥 인덱스에 직접 값을 계산하면, for문을 통해 1번 인덱스부터 3번인덱스 까지 +3하는 과정을 수행해야 한다.
그러나 누적합의 규칙을 이용하면 1번인덱스에 +3, 4번인덱스에 -3을 기록만 해두고 나중에 한번에 계산할 수 있다.
ex) 0 3 0 0 -3 -> 누적합 계산 -> 0 3 3 3 0
이 방식을 사용하여 매 스킬마다 피해누적을 계산하지 않고, 범위에 해당하는 곳에 +값과 -값을 적절히 기록만 해둔다.
마지막에 모든 기록을 누적합 계산하면 총 피해량을 구할 수 있다.

그러나, 이 문제는 2차원일 때 추가적인 아이디어가 필요하다.
예를 들어, 3*4의 2차원에서 0, 0부터 1, 1까지 3만큼 회복시킨다고 가정한다.
이 경우, 우측으로 누적합을 한번 계산한 뒤, 아래로 누적합을 한 번 더 계산한다.
이를 위해 가장 윗 가로줄의 왼쪽 끝점에 +, (오른쪽 끝점 + 1)에 -을 기록한다.
이 후, 가장 (아래 + 1) 가로줄의 왼쪽 끝점에 -, (오른쪽 끝점 + 1)에 +를 기록한다.
ex)
0 0 0 0      2 0 -2 0                                 2 2 0 0                                  2 2 0 0
0 0 0 0  -> 0 0 0 0  -> 가로 누적합 계산 ->  0 0 0 0  -> 세로 누적합 계산 ->  2 2 0 0
0 0 0 0     -2 0 2 0                                 -2-2 0 0                                  0 0 0 0

스킬 범위보다 바깥 쪽에 -를 취한 값을 기록하기 때문에, damage 배열의 크기를 board보다 가로세로로 1씩 더 크게 생성한다.
모든 스킬의 범위와 피해/회복량에 대해 기록이 끝난 후에, 한 번 위의 2차원 누적합 계산을 수행하면서 남아있는 건물 수를 센다.
'''
