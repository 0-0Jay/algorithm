# 백준 24337번 가희와 탑 : https://www.acmicpc.net/problem/24337

import sys
input = sys.stdin.readline

n, a, b = map(int, input().split())
arr = [1] * n
flag = 0
for i in range(-2, -(b + 1), -1):  # 오른쪽 채우기
    arr[i] += arr[i + 1]
    
if a > arr[-b]: arr[-b] = a  # 만약 오른쪽을 기준으로 올린 층
if n - b - a + 2 < 0: flag = 1

for i in range(n - b - a + 2, n - b):
    arr[i] += arr[i - 1]
    
if a == 1 and n - b > 0 :  # 특수한 경우 예외 처리
    arr[0] = arr[n - b]
    arr[n - b] = 1

if flag:
    print(-1)
else:
    for i in range(n):
        print(arr[i], end=" ")

# 알고리즘 : 그리디
'''
풀이 : 오른쪽부터 1씩 올려가며 채운 후, 채워진 인덱스를 기준으로 a만큼 떨어진 곳에서 1씩 올린다.
사전순으로 가장 앞선다는 것은 해당 숫자가 문자열일 경우엔 순서가 달라질 수 있다.
그러나 이 문제에서 사전순으로 가장 앞선 것은 배열에 있어서는 가능한 모든 경우의 수 중 가장 작은 것이므로
사전 순을 크게 고려하지 않아도 된다.

일단 수를 가장 작게 말하려면 높은 자릿수가 아닌, 낮은 자릿수부터 채우는 것이 유리하다.
따라서 오른쪽 끝부터 b만큼 1씩 올려가며 채운다.
ex) 8 3 4인 경우
1 1 1 1 1 1 1 1     ->     1 1 1 1 4 3 2 1

모두 채웠다면, -b인덱스에서 a만큼 왼쪽부터 1씩 증가시킨다
1 1 1 1 1 1 1 1     ->     1 1 1 2 4 3 2 1

만약 왼쪽이 더 크다면, -b인덱스를 왼쪽에서 올때의 최대값으로 변환 후, 진행한다.
ex 8 4 2인 경우
1 1 1 1 1 1 2 1     ->     1 1 1 1 1 1 4 1     ->     1 1 1 1 2 3 4 1

그리디적으로 생각했을 때, 우측부터 채워가는 것이 가장 작은 수를 만들 수 있다.
단, 왼쪽이 1인경우는 예외가 발생한다.
ex) 8 1 4인 경우
1 1 1 1 1 1 1 1     ->     1 1 1 1 4 3 2 1
위와 같이 오른쪽이 4까지 채워짐으로써 왼쪽에서 볼 수 있는 빌딩 수가 1, 4로 두 개가 된다.
따라서 왼쪽이 1인경우 가장 높은 빌딩을 가장 왼쪽으로 치환시켜 준다.
1 1 1 1 4 3 2 1     ->     4 1 1 1 1 3 2 1
'''
