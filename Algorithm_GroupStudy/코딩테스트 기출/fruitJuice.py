# 과일 주스

from collections import deque
import sys
input = sys.stdin.readline

def solution(fruit, k):
    chk = set()
    que = deque()
    fbit = []
    for i in range(len(fruit)):
        fbit.append(int(''.join((map(str, fruit[i]))), 2))
    answer = 0
    que.append((0, -1, 0))
    while que:
        now, id, cnt = que.popleft()
        if cnt == k:
            answer += 1
            continue
        for i in range(id + 1, len(fbit)):
            tmp = now | fbit[i]
            if (tmp, cnt + 1) not in chk:
                que.append((tmp, i, cnt + 1))
                chk.add((tmp, cnt + 1))
    return answer
        
print(solution([[1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 0]], 2))  # 1
print(solution([[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0],  [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1]], 3)) # 20
print(solution([[1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1]], 3)) # 7
print(solution([[(i % 2) for _ in range(12)] for i in range(100)], 50)) # 2

# 알고리즘 : 비트마스킹 + BFS
'''
풀이 : 각 과일의 맛 배열은 2진수로 보고, 10진수로 변환하여 과일을 섞을 때마다 비트 합연산한다.
이 문제를 단순 계산하게 되면 최악의 경우 다음과 같다.
-> 100개의 과일 중 50개를 선택하고 과일 중에 겹치는 맛이 없는 경우 -> 100C50 = 약 10^29 개
-> 고르는 것만 10^29이며 여기서 배열의 각 인덱스별 비교연산이 추가로 필요.
즉, 경우의 수를 단순히 계산하게 되면 너무 막대한 시간이 필요하게 된다.

따라서 시간을 획기적으로 줄이기 위해 2가지 방법을 사용한다.
1. 배열로 계산하지 않고, 배열을 그대로 이진수로 보고 10진수 숫자로 변환해 비트연산을 통해 숫자로 계산한다.
2. 문제에서 맛의 종류만을 요구했으므로 개수별로 중복된 맛이 발생한 경우, 추가 탐색하지 않게 방지한다.

먼저 fruit 배열에서 과일을 하나씩 꺼내 10진수 숫자로 변환하여 다른 배열에 저장한다.(fbit)
다음으로 초기값을 아무 맛도 없는 0으로 두고 bfs를 수행한다.
과일을 하나씩 뽑아서 현재 뽑은 맛(now)와 비트 합연산한 결과값을 큐에 넣는다.
이 때, 중복된 과일을 또 넣지 않게 인덱스(id)를 que에 함께 넣어 현재 인덱스 이후의 과일만 넣게 한다.
(now | fbit[i] 값, 사용한 과일 수)가 chk에 없을 때만 큐에 넣는다.
왜냐하면, 어떤 과일을 쓰던 같은 개수를 사용했을 때 똑같은 맛의 주스가 되었다면 1개로 카운팅하기 때문이다.
즉, 똑같은 종류의 맛에서 추가 탐색해도 중복된 맛만 발생하기 때문에 추가 탐색할 이유가 전혀 없다.
BFS를 수행하다 cnt가 k와 같아지면, answer에 1씩 추가한다.
앞의 중복 방지를 모두 통과한 조합이라는 의미이기 때문이다.

BFS 탐색이 끝나면, answer를 반환한다.
'''
